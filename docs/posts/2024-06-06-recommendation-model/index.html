<!DOCTYPE html>


<html lang="en-us" data-theme="">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    
        
<meta charset="utf-8">
<meta name="HandheldFriendly" content="True">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="referrer" content="no-referrer-when-downgrade">

<title>Recommendation Models - Bingz Learning Blog</title>

<meta name="description" content="An introduction to recommendation models">





<link rel="icon" type="image/x-icon" href="http://localhost:1313/favicon.ico">
<link rel="apple-touch-icon-precomposed" href="http://localhost:1313/favicon.png">






    



    



<style>
  body {
    visibility: hidden;
    opacity: 0;
  }
</style>

<noscript>
  <style>
    body {
      visibility: visible;
      opacity: 1;
    }
  </style>
</noscript>




    





    
    
    

    
        <link rel="stylesheet" href="/css/style.03df79c682b91915c7cd261ecd1a6ec4d0fe668c98fa46310d0fbade319b11bd.css" integrity="sha256-A995xoK5GRXHzSYezRpuxND&#43;ZoyY&#43;kYxDQ&#43;63jGbEb0=">
    





    





    
    
    

    
        <link rel="stylesheet" href="/css/style.9c1888ebff42c0224ce04dac10cb2c401f1b77f54f78e8d87d73c3bed781c263.css" integrity="sha256-nBiI6/9CwCJM4E2sEMssQB8bd/VPeOjYfXPDvteBwmM=">
    





    





    
    
    

    
        <link rel="stylesheet" href="/css/style.acd606c0fce58853afe0248d37bb41acbbcdd8b1aca2412b6c0fa760da0137f3.css" integrity="sha256-rNYGwPzliFOv4CSNN7tBrLvN2LGsokErbA&#43;nYNoBN/M=">
    












    

    





    
    
    

    
        <script src="/js/script.672e2309c296e07c18bcd08b28d797a56222ff941d65f308fba3158c44885b14.js" type="text/javascript" charset="utf-8" integrity="sha256-Zy4jCcKW4HwYvNCLKNeXpWIi/5QdZfMI&#43;6MVjESIWxQ="></script>
    



















    
</head>
<body>
    <a class="skip-main" href="#main">Skip to main content</a>
    <div class="container">
        <header class="common-header">
            
                <div class="header-top">
    <div class="header-top-left">
        <h1 class="site-title noselect">
    <a href="/">Bingz Learning Blog</a>
</h1>

        



    



    



    
        <div class="theme-switcher">
            <span class="inline-svg">

    


    
    
    
    
    

    <svg  xmlns="http://www.w3.org/2000/svg"  width="24"  height="24"  viewBox="0 0 24 24"  fill="none"  stroke="currentColor"  stroke-width="2"  stroke-linecap="round"  stroke-linejoin="round"  class="icon icon-tabler icons-tabler-outline icon-tabler-sun-high"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M14.828 14.828a4 4 0 1 0 -5.656 -5.656a4 4 0 0 0 5.656 5.656z" /><path d="M6.343 17.657l-1.414 1.414" /><path d="M6.343 6.343l-1.414 -1.414" /><path d="M17.657 6.343l1.414 -1.414" /><path d="M17.657 17.657l1.414 1.414" /><path d="M4 12h-2" /><path d="M12 4v-2" /><path d="M20 12h2" /><path d="M12 20v2" /></svg>


</span>

        </div>
    

    <script>
        const STORAGE_KEY = 'user-color-scheme'
        const defaultTheme = "auto"

        let currentTheme
        let switchButton
        let autoDefinedScheme = window.matchMedia('(prefers-color-scheme: dark)')

        function switchTheme(e) {
            currentTheme = (currentTheme === 'dark') ? 'light' : 'dark';
            if (localStorage) localStorage.setItem(STORAGE_KEY, currentTheme);
            document.documentElement.setAttribute('data-theme', currentTheme);
            changeGiscusTheme(currentTheme);
            document.body.dispatchEvent(new CustomEvent(currentTheme + "-theme-set"));
        }

        const autoChangeScheme = e => {
            currentTheme = e.matches ? 'dark' : 'light'
            document.documentElement.setAttribute('data-theme', currentTheme);
            changeGiscusTheme(currentTheme);
            document.body.dispatchEvent(new CustomEvent(currentTheme + "-theme-set"));
        }

        document.addEventListener('DOMContentLoaded', function () {
            switchButton = document.querySelector('.theme-switcher')
            currentTheme = detectCurrentScheme()

            if (currentTheme === 'auto') {
                autoChangeScheme(autoDefinedScheme);
                autoDefinedScheme.addListener(autoChangeScheme);
            } else {
                document.documentElement.setAttribute('data-theme', currentTheme)
            }

            if (switchButton) {
                switchButton.addEventListener('click', switchTheme, false)
            }

            showContent();
        })

        function detectCurrentScheme() {
            if (localStorage !== null && localStorage.getItem(STORAGE_KEY)) {
                return localStorage.getItem(STORAGE_KEY)
            }
            if (defaultTheme) {
                return defaultTheme
            }
            return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
        }

        function showContent() {
            document.body.style.visibility = 'visible';
            document.body.style.opacity = 1;
        }

        function changeGiscusTheme (theme) {
            function sendMessage(message) {
              const iframe = document.querySelector('iframe.giscus-frame');
              if (!iframe) return;
              iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
            }

            sendMessage({
              setConfig: {
                theme: theme
              }
            });
        }
    </script>


        <ul class="social-icons noselect">


    
        
        
        <li>
            <a href="https://github.com/bingzw" title="Github" rel="me">
            <span class="inline-svg">

    


    
    
    
    
    

    <svg  xmlns="http://www.w3.org/2000/svg"  width="24"  height="24"  viewBox="0 0 24 24"  fill="none"  stroke="currentColor"  stroke-width="2"  stroke-linecap="round"  stroke-linejoin="round"  class="icon icon-tabler icons-tabler-outline icon-tabler-brand-github"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5" /></svg>


</span>

            </a>
        </li>
    

    
        <li>
            <a href="https://www.linkedin.com/in/bingzw/" title="Linkedin" rel="me">
            <span class="inline-svg">

    


    
    
    
    
    

    <svg  xmlns="http://www.w3.org/2000/svg"  width="24"  height="24"  viewBox="0 0 24 24"  fill="none"  stroke="currentColor"  stroke-width="2"  stroke-linecap="round"  stroke-linejoin="round"  class="icon icon-tabler icons-tabler-outline icon-tabler-brand-linkedin"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M4 4m0 2a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v12a2 2 0 0 1 -2 2h-12a2 2 0 0 1 -2 -2z" /><path d="M8 11l0 5" /><path d="M8 8l0 .01" /><path d="M12 16l0 -5" /><path d="M16 16v-3a2 2 0 0 0 -4 0" /></svg>


</span>

            </a>
        </li>
    






    <li>
            <a href="/index.xml" title="RSS" rel="me">
            <span class="inline-svg">

    


    
    
    
    
    

    <svg  xmlns="http://www.w3.org/2000/svg"  width="24"  height="24"  viewBox="0 0 24 24"  fill="none"  stroke="currentColor"  stroke-width="2"  stroke-linecap="round"  stroke-linejoin="round"  class="icon icon-tabler icons-tabler-outline icon-tabler-rss"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M5 19m-1 0a1 1 0 1 0 2 0a1 1 0 1 0 -2 0" /><path d="M4 4a16 16 0 0 1 16 16" /><path d="M4 11a9 9 0 0 1 9 9" /></svg>


</span>

            </a>
        </li>
    

</ul>

    </div>
    <div class="header-top-right">

    </div>
</div>


    <nav class="noselect">
        
        
        <a class="" href="http://localhost:1313/" title="">Home</a>
        
        <a class="" href="http://localhost:1313/about/" title="">About</a>
        
        <a class="" href="http://localhost:1313/tags/" title="">Tags</a>
        
        <a class="" href="http://localhost:1313/posts/" title="">Archive</a>
        
    </nav>



<script>
  MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      displayMath: [['$$','$$'], ['\\[', '\\]']],
      processEscapes: true,
      processEnvironments: true
    },
    options: {
      skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
    }
  };

  window.addEventListener('load', (event) => {
      document.querySelectorAll("mjx-container").forEach(function(x){
        x.parentElement.classList += 'has-jax'})
    });

</script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script type="text/javascript" id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>





            
        </header>
        <main id="main" tabindex="-1">
            
    

    <article class="post h-entry">
        <div class="post-header">
            <header>
                <h1 class="p-name post-title">Recommendation Models</h1>
                

            </header>
            



<div class="post-info noselect">
    
        <div class="post-date dt-published">
            <time datetime="2024-06-06">2024-06-06</time>
            
        </div>
    

    <a class="post-hidden-url u-url" href="/posts/2024-06-06-recommendation-model/">/posts/2024-06-06-recommendation-model/</a>
    <a href="http://localhost:1313/" class="p-name p-author post-hidden-author h-card" rel="me"></a>


    <div class="post-taxonomies">
        
        
            <ul class="post-tags">
                
                    
                    <li><a href="/tags/machine-learning/">#Machine Learning</a></li>
                
                    
                    <li><a href="/tags/deep-learning/">#Deep Learning</a></li>
                
                    
                    <li><a href="/tags/recommendation/">#Recommendation</a></li>
                
                    
                    <li><a href="/tags/ranking/">#Ranking</a></li>
                
                    
                    <li><a href="/tags/personalization/">#Personalization</a></li>
                
            </ul>
        
        
    </div>
</div>

        </div>
        

  
  




  
  
  
  <details class="toc noselect">
    <summary>Table of Contents</summary>
    <div class="inner"><nav id="TableOfContents">
  <ul>
    <li><a href="#introduction-to-recommendation-models">Introduction to Recommendation Models</a></li>
    <li><a href="#collaborative-filtering-cf">Collaborative Filtering (CF)</a>
      <ul>
        <li><a href="#memory-based-cf">Memory Based CF</a>
          <ul>
            <li><a href="#user-user-filtering">User User Filtering</a></li>
            <li><a href="#item-item-filtering">Item Item Filtering</a></li>
          </ul>
        </li>
        <li><a href="#model-based-cf">Model Based CF</a>
          <ul>
            <li><a href="#clustering">Clustering</a></li>
            <li><a href="#matrix-factorization">Matrix Factorization</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#content-based-models-ranking-as-recommendation">Content Based Models (Ranking As Recommendation)</a>
      <ul>
        <li><a href="#wide--deep4">Wide &amp; Deep</a></li>
        <li><a href="#deepfm5">DeepFM</a></li>
        <li><a href="#deep-learning-recommendation-model-dlrm6">Deep Learning Recommendation Model (DLRM)</a></li>
        <li><a href="#deep--cross-network-v2-dcn-v27">Deep &amp; Cross Network v2 (DCN v2)</a></li>
        <li><a href="#deep-interest-network-din8">Deep Interest Network (DIN)</a></li>
        <li><a href="#multi-gate-mixture-of-experts-mmoe9">Multi-gate Mixture of Experts (MMOE)</a></li>
        <li><a href="#behavior-sequence-transformer-bst10">Behavior Sequence Transformer (BST)</a></li>
      </ul>
    </li>
    <li><a href="#summary">Summary</a></li>
    <li><a href="#citation">Citation</a></li>
    <li><a href="#reference">Reference</a></li>
  </ul>
</nav></div>
  </details>
  



<script>
  var toc = document.querySelector(".toc");
  if (toc) {
    toc.addEventListener("click", function () {
      if (event.target.tagName !== "A") {
        event.preventDefault();
        if (this.open) {
          this.open = false;
          this.classList.remove("expanded");
        } else {
          this.open = true;
          this.classList.add("expanded");
        }
      }
    });
  }
</script>

        <div class="content e-content">
            <p align="center">
<img src="/recommendation_model/reco.jpeg" width="600" height="400"><br>
<p>
<p><em>Image cited from <a href="https://www.vecteezy.com/">vecteezy</a></em></p>
<h2 id="introduction-to-recommendation-models" >
<div>
    <a href="#introduction-to-recommendation-models">
        
    </a>
    Introduction to Recommendation Models
</div>
</h2>
<p>In the digital age, the sheer volume of available content and products can be overwhelming for users. Recommendation
systems play a crucial role in helping users discover relevant items by filtering through vast amounts of data. These
systems are integral to various industries, including e-commerce, streaming services, social media, and online
advertising.</p>
<p>Recommendation models are algorithms designed to suggest items to users based on various factors such as past behavior,
preferences, and item characteristics. The goal is to enhance user experience by providing personalized recommendations,
thereby increasing engagement and satisfaction.</p>
<p>In most cases, the goal is trying to find the most appealing item for the user given all user demographic, behavior and
interest information. A well-designed recommendation system usually results in better personalization, user engagement,
and revenue generation. Let&rsquo;s take a look at the most popular modeling approaches.</p>
<h2 id="collaborative-filtering-cf" >
<div>
    <a href="#collaborative-filtering-cf">
        
    </a>
    Collaborative Filtering (CF)
</div>
</h2>
<p>Collaborative Filtering is one of the most famous recommendation models so far. It&rsquo;s about to guess the user&rsquo;s interest
based on the behaviors and preferences of other users with similar tastes/characteristics. This basic approach is
straightforward and only requires user-item interaction history.</p>
<h3 id="memory-based-cf" >
<div>
    <a href="#memory-based-cf">
        
    </a>
    Memory Based CF
</div>
</h3>
<p>Suppose the recommendation is purely derived from historical records and it does not involve any predictive modelings.
Let&rsquo;s assume a table of all ratings of users on items. Let $r_{u,i}$ denotes the missing rating of user $u$ on item $i$.
$S_u$ be a set of users that share similar characteristics with user $u$. $P_j$ denotes a set of items that are close to
item $j$. The goal is to guess the missing rating $r_{u,i}$. Let&rsquo;s start expressing the &ldquo;predicted&rdquo; rating from either user-user
filtering or item-item filtering.</p>
<h4 id="user-user-filtering" >
<div>
    <a href="#user-user-filtering">
        
    </a>
    User User Filtering
</div>
</h4>
<p>Assume that users with a similar profile share a similar taste. We are predicting the missing rating as the weighted
average from ratings of similar users:</p>
<p align="center">
$r_{u,i} = \bar{r}_u + \frac{\sum_{u'\in S_u}sim(u, u') * (r_{u',i} - \bar{r}_{u'})}{\sum_{u'\in S_u}sim(u, u')}$
<p>
<p>where $\bar{r}_u$ is the average rating of user $u$ and $sim(u, u&rsquo;)$ represents the similarity score between user $u$
and $u&rsquo;$. A common choice is to calculate the cosine similarity between two user rating vectors.</p>
<h4 id="item-item-filtering" >
<div>
    <a href="#item-item-filtering">
        
    </a>
    Item Item Filtering
</div>
</h4>
<p>Assume that the customers will prefer products that share a high similarity with those already well appreciated. The
missing rating is thus predicted as the weighted average of a set of similar products:</p>
<p>$$r_{u,i} = \frac{\sum_{j \in P_i}sim(j, i) * r_{u,j}}{\sum_{j \in P_i}sim(j, i)}$$</p>
<p>It&rsquo;s straightforward to observe that user-based filtering is to check what other users think of the same product, while
item-based filtering is aggregating what the user thinks of other items. Essentially, both are weighted linear
combination of observed ratings. Can we do better than weighted average?</p>
<h3 id="model-based-cf" >
<div>
    <a href="#model-based-cf">
        
    </a>
    Model Based CF
</div>
</h3>
<p>Unlike the memory based CF which is trying to fill in the missing cells in the rating matrix, model-based collaborative
filtering is to predict user preferences for items based on past interactions. It often relies on the concept of
latent factors. These are hidden features that influence user preferences and item characteristics. By uncovering these
latent factors, the model can predict the likelihood of a user liking an item.</p>
<p>Let $R$ denotes the user item interaction rating matrix, $R \in \mathbb{R}^{m*n}$, where $m$ is the dimension of user
space and $n$ denotes the dimension of item space.</p>
<h4 id="clustering" >
<div>
    <a href="#clustering">
        
    </a>
    Clustering
</div>
</h4>
<p>Given user or item embeddings, a simple approach is to apply the K nearest neighbours to find the K closest users or
items depending on the similarity metrics used.</p>
<h4 id="matrix-factorization" >
<div>
    <a href="#matrix-factorization">
        
    </a>
    Matrix Factorization
</div>
</h4>
<p>The basic idea is to decompose the user-item interaction matrix into two lower-dimensional matrices:</p>
<ul>
<li><strong>User Matrix (U)</strong>: Represents users in terms of latent factors, $U \in \mathbb{R}^{m * p}$, where $p$ is the dimension
of the latent space.</li>
<li><strong>Item Matrix (V)</strong>: Represents items in terms of latent factors, $V \in \mathbb{R}^{n * p}$</li>
</ul>
<p>The interaction matrix $R$ is approximated as the product of these two matrices: $R \approx U \cdot V^T$. In practice, we
are usually optimizing for a weighted matrix factorization objective<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup></p>
<p>$$L(\theta) = \sum_{(i, j)\in obs} \omega_{i, j} (R_{i, j} - U_i \cdot V_{j}^{T})^2 + \omega_{0} \sum_{(i, j) \notin obs}
(U_i \cdot V_{j}^{T})^2$$</p>
<p>where $\omega_0$ is a hyper-parameter that weights the two terms so that the objective is not
dominated by one or the other, and $\omega_{i, j}$ is a function of the frequency of user $i$ and item $j$.</p>
<p>Common optimization algorithms to minimize the above objective function includes <strong>stochastic gradient descent</strong> and
<strong>weighted alternating least squares (WALS)</strong>.</p>
<p>Recently, a few efforts on deep learning have also been proposed on matrix factorization. For example,</p>
<h5 id="deep-auto-encoders2" >
<div>
    <a href="#deep-auto-encoders2">
        
    </a>
    Deep Auto-Encoders<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup>
</div>
</h5>
<p>It proposed a model called Collaborative Denoising Auto-Encoder (CDAE) that extends the traditional denoising autoencoder
architecture to the collaborative filtering domain. CDAE is designed to handle implicit feedback, where user preferences
are inferred from user behavior rather than explicit ratings. The model incorporates both user-specific and item-specific
factors, leveraging the rich user interaction data to learn better representations for recommendation tasks.</p>
<p align="center">
    <img src="/recommendation_model/autoencoder_mf.png"><br>
    <em>Figure 1: deep auto-encoder</em>
</p>
<h5 id="neural-collaborative-filtering3" >
<div>
    <a href="#neural-collaborative-filtering3">
        
    </a>
    Neural Collaborative Filtering<sup id="fnref:3"><a href="#fn:3" class="footnote-ref" role="doc-noteref">3</a></sup>
</div>
</h5>
<p>NCF replaces these linear latent factor models with non-linear neural networks, allowing for a more expressive
representation of user-item interactions. By doing so, NCF can capture more complex patterns in the data that traditional
methods might miss. The core idea is to use multi-layer perceptrons (MLPs) to model the interaction function between
users and items, providing a more flexible and powerful framework for learning user preferences.</p>
<p>The general architecture of NCF includes embedding layers for users and items, followed by one or more hidden layers
that learn the interaction between these embeddings. The final output layer predicts the user&rsquo;s preference for a given
item. This approach not only improves the accuracy of recommendations but also enables the integration of additional
features, such as user demographics or item attributes, into the model. Refer to the DLRM or DeepFM for more details.</p>
<p align="center">
    <img src="/recommendation_model/ncf_mf.png"><br>
    <em>Figure 2: neural collaborative filtering</em>
</p>
<h2 id="content-based-models-ranking-as-recommendation" >
<div>
    <a href="#content-based-models-ranking-as-recommendation">
        
    </a>
    Content Based Models (Ranking As Recommendation)
</div>
</h2>
<p>Unlike the collaborative filtering that purely relies on user-item interaction data. Content-based recommendation models
focus on the attributes of items to suggest similar items to users based on their past interactions. These models analyze
the content (such as text, keywords, categories, or features) associated with the items and create a profile for each
user based on the features of the items they have shown interest in. Compared with collaborative filtering, it&rsquo;s easier
to handle the cold start issue when item features are known. However, its recommendation may strictly adheres to the
user&rsquo;s profile, potentially limiting diversity. There are quite a few popular model frameworks in this area and we would
focus on the models based on deep neural architecture.</p>
<h3 id="wide--deep4" >
<div>
    <a href="#wide--deep4">
        
    </a>
    Wide &amp; Deep<sup id="fnref:4"><a href="#fn:4" class="footnote-ref" role="doc-noteref">4</a></sup>
</div>
</h3>
<p>Wide &amp; Deep learning combined wide linear models and deep neural networks to achieve both memorization and generalization.
The model consists of two components:</p>
<ol>
<li>
<p><strong>Wide Component</strong>: This part is a generalized linear model (GLM) that excels at memorization by capturing feature
interactions using cross-product feature transformations. The wide component is effective at handling sparse features
and explicitly memorizing frequent co-occurrence patterns. It can be represented as:</p>
<p>$$y_{\text{wide}} = \mathbf{w}^T \mathbf{x} + b $$</p>
<p>where $\mathbf{x}$ represents the input features, $\mathbf{w}$ represents the learned weights, and $b$ is
the bias term.</p>
</li>
<li>
<p><strong>Deep Component</strong>: This part is a feed-forward neural network that excels at generalization by capturing high-level
and non-linear feature interactions. The deep component uses dense embeddings to represent categorical features, and it
learns implicit interactions through multiple hidden layers. The output of the deep component can be represented as:</p>
<p>$$\mathbf{h}^L = f^L(\mathbf{W}^L \mathbf{h}^{L-1} + \mathbf{b}^L)$$</p>
<p>where $\mathbf{h}^L$ is the activation of the $L$-th layer, $\mathbf{W}^L$ and $\mathbf{b}^L$ are the weights and biases
of the $L$-th layer, respectively, and $f^L$ is the activation function.
The final output of the deep component, $ y_{\text{deep}} $, is the output of the last layer of the deep neural network. It is given by:</p>
<p>$$
y_{\text{deep}} = \mathbf{W}^O \mathbf{h}^{L} + \mathbf{b}^O
$$</p>
<p>where $ \mathbf{W}^O $ and $ \mathbf{b}^O $ are the weights and bias of the output layer, and $ \mathbf{h}^L $ is the activation of the last hidden layer.</p>
<p>The final prediction is a weighted sum of the outputs from the wide and deep components:</p>
<p>$$\hat{y} = \sigma(y_{\text{wide}} + y_{\text{deep}})$$</p>
<p>where $\sigma$ is the sigmoid function used to squash the output to a probability score.</p>
</li>
</ol>
<p align="center">
   <img src="/recommendation_model/wide_deep.png" width="800" height="600"><br>
   <em>Figure 3: wide & deep model</em>
</p>
<h3 id="deepfm5" >
<div>
    <a href="#deepfm5">
        
    </a>
    DeepFM<sup id="fnref:5"><a href="#fn:5" class="footnote-ref" role="doc-noteref">5</a></sup>
</div>
</h3>
<p>DeepFM addresses the challenge of capturing both low-order and high-order feature interactions in recommendation systems.
The model consists of two interconnected components:</p>
<ol>
<li>
<p><strong>FM Component</strong>: This part captures low-order feature interactions using Factorization Machines, which are effective
for handling sparse data and modeling pairwise feature interactions without manual feature engineering. The FM component
can be represented as:</p>
<p>$$
y_{\text{FM}} = w_0 + \sum_{i=1}^n w_i x_i + \sum_{i=1}^n \sum_{j=i+1}^n \langle \mathbf{v}_i, \mathbf{v}_j \rangle x_i x_j
$$</p>
<p>where $w_0$ is the global bias, $w_i$ is the weight of the $i$-th feature, $\mathbf{v}_i$ and $\mathbf{v}_j$ are
latent vectors for the $i$-th and $j$-th features, respectively, and $x_i$ and $x_j$ are input feature values.</p>
</li>
<li>
<p><strong>Deep Component</strong>: This part captures high-order feature interactions through a deep neural network. The deep
component uses embeddings to represent input features and learns complex interactions through multiple hidden layers.
The output of the deep component can be represented as:</p>
<p>$$\mathbf{h}^L = f^L(\mathbf{W}^L \mathbf{h}^{L-1} + \mathbf{b}^L)$$</p>
<p>where $\mathbf{h}^L$ is the activation of the $L$-th layer, $\mathbf{W}^L$ and $\mathbf{b}^L$ are the weights and
biases of the $L$-th layer, respectively, and $f^L$ is the activation function.
The final output of the deep component, $ y_{\text{deep}} $, is the output of the last layer of the deep neural network. It is given by:</p>
<p>$$
y_{\text{deep}} = \mathbf{W}^O \mathbf{h}^{L} + \mathbf{b}^O
$$</p>
<p>where $ \mathbf{W}^O $ and $ \mathbf{b}^O $ are the weights and bias of the output layer, and $ \mathbf{h}^L $ is the
activation of the last hidden layer.</p>
</li>
</ol>
<p>The final prediction is a combination of the outputs from the FM and deep components:</p>
<p>$$\hat{y} = \sigma(y_{\text{FM}} + y_{\text{deep}})$$</p>
<p>where $\sigma$ is the sigmoid function used to squash the output to a probability score.</p>
<p align="center">
   <img src="/recommendation_model/deepfm.png" width="600" height="400"><br>
   <em>Figure 4: deepfm model</em>
</p>
<h3 id="deep-learning-recommendation-model-dlrm6" >
<div>
    <a href="#deep-learning-recommendation-model-dlrm6">
        
    </a>
    Deep Learning Recommendation Model (DLRM)<sup id="fnref:6"><a href="#fn:6" class="footnote-ref" role="doc-noteref">6</a></sup>
</div>
</h3>
<p>Deep Learning Recommendation Model (DLRM) is an advanced machine learning framework designed by Facebook AI to tackle
the complex challenge of personalized recommendations at scale. It is particularly suited for large-scale recommendation
systems in environments such as social media platforms, e-commerce, and online advertising. The DLRM combines the
strengths of collaborative filtering and content-based methods by utilizing both dense and sparse features to provide
highly accurate and scalable recommendations.</p>
<p align="center">
   <img src="/recommendation_model/dlrm.png" width="600" height="400"><br>
   <em>Figure 5: deep learning recommendation model</em>
</p>
<p>Key components of DLRM includes</p>
<ol>
<li>
<p><strong>Sparse Features</strong>: These are categorical variables (e.g., user ID, item ID) which are typically represented using
embeddings. Embeddings transform sparse categorical data into dense vectors of continuous numbers, making them suitable
for neural network processing, denoted as $\mathbf{x}_s[i]$.
The raw sparse features are transformed to sparse embeddings as follows. Let
$$
\mathbf{e}_i = \text{Embedding}(\mathbf{x}_s[i])
$$
where $\mathbf{e}_i$ is the embedding vector for the $i$-th sparse feature, $\text{Embedding}$ denotes an embedding lookup table</p>
</li>
<li>
<p><strong>Dense Features</strong>: These are numerical variables (e.g., user age, item price) that are used directly in their raw
form or normalized form, denoted as $\mathbf{x}_d$.</p>
</li>
<li>
<p><strong>Bottom MLP (Multilayer Perceptron)</strong>: Processes the dense features to capture high-level representations.
$$
\mathbf{h}_d = \text{BottomMLP}(\mathbf{x}_d)
$$</p>
</li>
<li>
<p><strong>Interaction Layer</strong>: This layer captures the interactions between different features (both sparse and dense). It
uses a dot product to compute the pairwise interactions among features.
$$
\mathbf{z} = \left[ \mathbf{h}_d, \mathbf{e}_1, \mathbf{e}_2, \ldots, \mathbf{e}_n \right]
$$
where $\mathbf{z}$ is the concatenated vector of dense feature representation and embeddings.</p>
</li>
<li>
<p><strong>Top MLP</strong>: Combines the processed dense features and interactions from the interaction layer to make the final prediction.
$$
\hat{y} = \sigma(\text{TopMLP}(\mathbf{z}))
$$
where $\sigma$ is an activation function, typically a sigmoid function for binary classification tasks.</p>
</li>
</ol>
<h3 id="deep--cross-network-v2-dcn-v27" >
<div>
    <a href="#deep--cross-network-v2-dcn-v27">
        
    </a>
    Deep &amp; Cross Network v2 (DCN v2)<sup id="fnref:7"><a href="#fn:7" class="footnote-ref" role="doc-noteref">7</a></sup>
</div>
</h3>
<p>DCN-V2 starts with an embedding layer, followed by a cross network containing multiple cross layers that models explicit
feature interactions, and then combines with a deep network that models implicit feature interactions. The function class
modeled by DCN-V2 is a strict superset of that modeled by DCN. The overall model architecture is depicted in Fig. 5, with
two ways to combine the cross network with the deep network: (1) stacked and (2) parallel.</p>
<ol>
<li>
<p><strong>Cross Component</strong>: The Cross Network V2 enhances the original cross network by introducing a more flexible mechanism
to capture feature interactions. The cross layer in DCN V2 can be represented as:</p>
<p>$$
x_{l+1} = x_0 \odot (W_l \cdot x_l + b_l) + x_l
$$</p>
<p>where $x_l$ is the input to the l-th cross layer. $W_l$ and $b_l$ are the weight matrix and bias vector of the l-th
cross layer. $x_{l+1}$ is the output of the $l+1$-th cross layer. $\odot$ is the Hadamard product.</p>
</li>
<li>
<p><strong>Deep Component</strong>: The deep network in DCN V2 captures high-order feature interactions through a series of dense layers.
This part of the network learns abstract representations of the input features, enabling the model to generalize well.</p>
<p>$$
h_{l} = f_{l}(W_{l} h_{l-1} + b_{l})
$$</p>
<p>where $h_{l}$ is the activation of the $l$-th layer, $W_{l}$ and $b_{l}$ are the weights and
biases of the $l$-th layer, respectively, and $f_{l}$ is the activation function.</p>
</li>
</ol>
<p>The final prediction is a combination of the outputs from either the hidden layer (stacked structure) or the  concatenation
of cross and deep network outputs.</p>
<p align="center">
   <img src="/recommendation_model/dcn_v2.png" width="600" height="400"><br>
   <em>Figure 6: deep cross network v2</em>
</p>
<h3 id="deep-interest-network-din8" >
<div>
    <a href="#deep-interest-network-din8">
        
    </a>
    Deep Interest Network (DIN)<sup id="fnref:8"><a href="#fn:8" class="footnote-ref" role="doc-noteref">8</a></sup>
</div>
</h3>
<p>Deep Interest Network (DIN) is a neural network-based model designed for personalized recommendation systems, particularly
in the context of e-commerce and advertising. Unlike traditional recommendation models that primarily focus on user-item interactions,
DIN leverages a user&rsquo;s historical behavior to make more accurate and contextually relevant recommendations. The key
innovation in DIN is its ability to capture user interests dynamically and use this information to influence the recommendation
process.</p>
<p align="center">
   <img src="/recommendation_model/din.png" width="800" height="600"><br>
   <em>Figure 7: deep interest network</em>
</p>
<p>In particular, the DIN contains the following key components:</p>
<ol>
<li>
<p><strong>Embedding Layer</strong>: User behaviors and items are represented as dense vectors through an embedding layer. Let
$({e_{1}, e_{2}, \ldots, e_{n}})$ be the sequence of embeddings for user behaviors, and $e_{target}$ be the embedding of the target item.</p>
</li>
<li>
<p><strong>Local Activation Unit</strong>: This unit applies the attention mechanism to compute the relevance of each user behavior
in the sequence with respect to the target item.
Let
$$
\alpha_{i} = \frac{\exp(\text{score}(e_{i}, e_{target}))}{\sum_{j=1}^{n} \exp(\text{score}(e_{j}, e_{target}))}
$$
where $\text{score}(e_{i}, e_{target})$ is the activation weight output from a feed-forward
network measuring the relevance of behavior $e_{i}$ to the target item.</p>
</li>
<li>
<p><strong>Interest Extractor Layer</strong>: Combines the weighted behavior embeddings to form a user interest representation.
$$
u = \sum_{i=1}^{n} \alpha_{i} e_{i}
$$</p>
</li>
<li>
<p><strong>Prediction Layer</strong>: The user interest representation is concatenated with the target item embedding and fed into a neural network to predict the user&rsquo;s interaction with the target item.
$$
\hat{y} = \sigma(W[u, e_{target}, e_{profile}, e_{context}] + b)
$$
where $[u, e_{target}, e_{profile}, e_{context}]$ denotes the concatenation of the user interest representation, profile
embedding, context embedding and the target item embedding, $W$ is a weight matrix, $b$ is a bias term, and $\sigma$ is an activation function (e.g., sigmoid).</p>
</li>
</ol>
<h3 id="multi-gate-mixture-of-experts-mmoe9" >
<div>
    <a href="#multi-gate-mixture-of-experts-mmoe9">
        
    </a>
    Multi-gate Mixture of Experts (MMOE)<sup id="fnref:9"><a href="#fn:9" class="footnote-ref" role="doc-noteref">9</a></sup>
</div>
</h3>
<p>Multi-gate Mixture-of-Experts (MMoE) is an advanced multi-task learning (MTL) framework designed to model and leverage
task relationships for improved performance across multiple tasks. The MMoE architecture combines the benefits of
mixture-of-experts models with the flexibility of multi-gate mechanisms, allowing the model to dynamically allocate
computational resources based on the specific needs of each task. This approach is particularly useful in scenarios
where tasks are interrelated and can benefit from shared learning while maintaining task-specific adaptations.</p>
<p align="center">
   <img src="/recommendation_model/mmoe.png" width="800" height="600"><br>
   <em>Figure 8: multi-gate mixture of experts</em>
</p>
<p>Key components of the model architecture are:</p>
<ol>
<li>
<p><strong>Experts</strong>: A set of neural network sub-models that serve as specialized units for feature extraction. Each expert
is trained to capture different aspects of the input data. Let $\mathbf{x}$ represent the input data, $E$ represent
the number of experts, and $T$ represent the number of tasks. The output from expert is represented as
$$
\mathbf{h}^i = f_e^i(\mathbf{x}), \quad \text{for } i = 1, 2, \ldots, E
$$
where $f_e^i$ is the function of the $i$-th expert, and $\mathbf{h}^i$ is the output of the $i$-th expert.</p>
</li>
<li>
<p><strong>Multi-gate Mechanism</strong>: Separate gating networks for each task that dynamically select and weight the contributions
of different experts based on the input data and task requirements.
$$
\mathbf{g}^j = \sigma(\mathbf{W}^j \mathbf{x}), \quad \text{for } j = 1, 2, \ldots, T
$$
where $\mathbf{W}^j$ are the parameters of the gating network for task $j$, and $g^j$ is the gating output distribution
of gating weights to each expert assigned by task $j$. To combine the experts output and gating weights, we have
$$\mathbf{t}^j = \sum_{i=1}^{E} g_i^j \cdot \mathbf{h}^i$$
where $\mathbf{t}^j$ is the combined output for task $j$, and $g_i^j$ is the weight for the $i$-th expert assigned by
the gating network of task $j$.</p>
</li>
<li>
<p><strong>Task-specific Layers</strong>: Layers that process the combined outputs from the experts, tailored to the specific requirements of each task.
$$
\hat{y}^j = f_o^j(\mathbf{t}^j)
$$
where $f_o^j$ is the task-specific output layer for task $j$, and $\hat{y}^j$ is the predicted output for task $j$.</p>
</li>
</ol>
<h3 id="behavior-sequence-transformer-bst10" >
<div>
    <a href="#behavior-sequence-transformer-bst10">
        
    </a>
    Behavior Sequence Transformer (BST)<sup id="fnref:10"><a href="#fn:10" class="footnote-ref" role="doc-noteref">10</a></sup>
</div>
</h3>
<p>The Behavior Sequence Transformer (BST) is a novel neural network architecture designed for modeling user behavior
sequences in recommendation systems. BST leverages the power of Transformer models, which have achieved significant
success in natural language processing (NLP), to capture the sequential patterns and contextual dependencies in user
interactions over time. This approach enhances the ability to predict user preferences and improve recommendation accuracy.</p>
<p align="center">
   <img src="/recommendation_model/bst.png" width="800" height="600"><br>
   <em>Figure 9: behavior sequence transformer</em>
</p>
<p>Key components of BST include:</p>
<ol>
<li><strong>Input Layer</strong>:</li>
</ol>
<ul>
<li><strong>User Behavior Sequence</strong>: A sequence of items or actions representing user interactions over time.</li>
<li><strong>Contextual Features</strong>: Additional information such as timestamps, device types, and other relevant context.</li>
</ul>
<ol start="2">
<li>
<p><strong>Embedding Layer</strong>:
$$
\mathbf{E}_x = \mathbf{W}_e \cdot \mathbf{x}
$$
where $\mathbf{W}_e$ is the embedding matrix and $\mathbf{x}$ is the input feature vector.</p>
</li>
<li>
<p><strong>Positional Encoding</strong>:
$$
\mathbf{E}_p = \text{PE}(pos)
$$
where $\text{PE}(pos)$ is the positional encoding function that adds position-specific information to the embeddings.</p>
</li>
<li>
<p><strong>Transformer Encoder</strong>:
$$
\mathbf{H}_i = \text{LayerNorm}(\text{MultiHeadAttention}(\mathbf{Q}, \mathbf{K}, \mathbf{V}) + \mathbf{E}_i)
$$
where $\mathbf{Q}$, $\mathbf{K}$, and $\mathbf{V}$ are the query, key, and value matrices, and $\mathbf{E}_i$ is the
input embedding at layer $i$. A Feed-Forward Networks ($\text{FFN}$) is added on top of the self attention layer to further enhance the
model with non-linearity.
$$
\mathbf{O}_i = \text{LayerNorm}(\text{FFN}(\mathbf{H}_i) + \mathbf{H}_i)
$$
In practice, we usually stack multiple transformer layers. So the output of last layer is thus fed as the input of the
next layer.</p>
</li>
<li>
<p><strong>Output Layer</strong>:
$$
\hat{y} = \sigma(\mathbf{W}_o \cdot \mathbf{O}_L)
$$
where $\mathbf{W}_o$ is the weight matrix of the output layer, $\mathbf{O}_L$ is the output of the last Transformer encoder layer, and $\sigma$ is the activation function.</p>
</li>
</ol>
<h2 id="summary" >
<div>
    <a href="#summary">
        
    </a>
    Summary
</div>
</h2>
<p>So far, we have summarized the main popular recommendation models. These summaries highlight the unique strengths and
specific applications of each recommendation model, reflecting their advancements and contributions to the field. The
modern recommendation systems usually are built with multiple stages and are composed with both simple and complex models.
Users may choose the best model depending on the business requirements and system architecture design.</p>
<h2 id="citation" >
<div>
    <a href="#citation">
        
    </a>
    Citation
</div>
</h2>
<p>If you find this post helpful, please consider citing it as:</p>
<div class="highlight"><pre tabindex="0" style="color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bibtex" data-lang="bibtex"><span style="display:flex;"><span><span style="color:#f3f99d">@article</span>{<span style="color:#ff5c57">wang2024recommendationmodel</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#57c7ff">author</span> = <span style="color:#5af78e">&#34;Bing Wang&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#57c7ff">title</span> = <span style="color:#5af78e">&#34;Recommendation Models&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#57c7ff">journal</span> = <span style="color:#5af78e">&#34;bingzw.github.io&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#57c7ff">year</span> = <span style="color:#5af78e">&#34;2024&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#57c7ff">month</span> = <span style="color:#5af78e">&#34;June&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#57c7ff">url</span> = <span style="color:#5af78e">&#34;https://bingzw.github.io/posts/2024-06-06-recommendation-model/&#34;</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>or</p>
<div class="highlight"><pre tabindex="0" style="color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-markdown" data-lang="markdown"><span style="display:flex;"><span>Bing Wang. (2024, June). Recommendation Models. 
</span></span><span style="display:flex;"><span>https://bingzw.github.io/posts/2024-06-06-recommendation-model/
</span></span></code></pre></div><h2 id="reference" >
<div>
    <a href="#reference">
        
    </a>
    Reference
</div>
</h2>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p><a href="https://developers.google.com/machine-learning/recommendation/collaborative/matrix">Collaborative Filtering and Matrix Factorization</a>&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2">
<p><a href="https://arxiv.org/pdf/1708.01715">Kuchaiev, Oleksii, and Boris Ginsburg. &ldquo;Training deep autoencoders for collaborative filtering.&rdquo; arXiv preprint arXiv:1708.01715 (2017)</a>&#160;<a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:3">
<p><a href="https://arxiv.org/pdf/1708.05031">He, Xiangnan, et al. &ldquo;Neural collaborative filtering.&rdquo; Proceedings of the 26th international conference on world wide web. 2017</a>&#160;<a href="#fnref:3" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:4">
<p><a href="https://arxiv.org/pdf/1606.07792">Cheng, Heng-Tze, et al. &ldquo;Wide &amp; deep learning for recommender systems.&rdquo; Proceedings of the 1st workshop on deep learning for recommender systems. 2016</a>&#160;<a href="#fnref:4" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:5">
<p><a href="https://arxiv.org/pdf/1703.04247">Guo, Huifeng, et al. &ldquo;DeepFM: a factorization-machine based neural network for CTR prediction.&rdquo; arXiv preprint arXiv:1703.04247 (2017)</a>&#160;<a href="#fnref:5" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:6">
<p><a href="https://arxiv.org/pdf/1906.00091">Naumov, Maxim, et al. &ldquo;Deep learning recommendation model for personalization and recommendation systems.&rdquo; arXiv preprint arXiv:1906.00091 (2019)</a>&#160;<a href="#fnref:6" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:7">
<p><a href="https://arxiv.org/pdf/2008.13535">Wang, Ruoxi, et al. &ldquo;Dcn v2: Improved deep &amp; cross network and practical lessons for web-scale learning to rank systems.&rdquo; Proceedings of the web conference 2021. 2021</a>&#160;<a href="#fnref:7" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:8">
<p><a href="https://arxiv.org/pdf/1706.06978">Zhou, Guorui, et al. &ldquo;Deep interest network for click-through rate prediction.&rdquo; Proceedings of the 24th ACM SIGKDD international conference on knowledge discovery &amp; data mining. 2018</a>&#160;<a href="#fnref:8" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:9">
<p><a href="https://dl.acm.org/doi/pdf/10.1145/3219819.3220007">Ma, Jiaqi, et al. &ldquo;Modeling task relationships in multi-task learning with multi-gate mixture-of-experts.&rdquo; Proceedings of the 24th ACM SIGKDD international conference on knowledge discovery &amp; data mining. 2018</a>&#160;<a href="#fnref:9" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:10">
<p><a href="https://arxiv.org/pdf/1905.06874">Chen, Qiwei, et al. &ldquo;Behavior sequence transformer for e-commerce recommendation in alibaba.&rdquo; Proceedings of the 1st international workshop on deep learning practice for high-dimensional sparse data. 2019</a>&#160;<a href="#fnref:10" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>
        </div>

    </article>

    
    
        
    

    
        
        
    

    

    
        








            

<script>
        function detectCurrentScheme2() {
                const defaultTheme = "auto";
                if (localStorage !== null && localStorage.getItem("user-color-scheme")) {
                        return localStorage.getItem("user-color-scheme");
                }
                if (defaultTheme === "dark" || defaultTheme === "light") {
                        return defaultTheme;
                }
                return window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light";
        }

        let giscusTheme = detectCurrentScheme2();
        let giscusAttributes = {
                src: "https://giscus.app/client.js",
                "data-repo": "Bingzw\/bingzw.github.io",
                "data-repo-id": "R_kgDOMB8LQg",
                "data-category": "Announcements",
                "data-category-id": "DIC_kwDOMB8LQs4CfrMr",
                "data-mapping": "pathname",
                "data-strict": "0",
                "data-reactions-enabled": "1",
                "data-emit-metadata": "0",
                "data-input-position": "bottom",
                "data-theme": giscusTheme,
                "data-lang": "en",
                crossorigin: "anonymous",
                lazyload: "false",
                async: true,
        };
        let main = document.querySelector("main");
        let giscusScript = document.createElement("script");
        Object.entries(giscusAttributes).forEach(([key, value]) => giscusScript.setAttribute(key, value));
        main.appendChild(giscusScript);
</script>




    

    

    

        </main>
        
            <footer class="common-footer noselect">
    
    

    <div class="common-footer-bottom">
        

        <div style="display: flex; align-items: center; gap:8px">
            Â© Bing Wang, 2024
            
        </div>
        <div style="display:flex;align-items: center">
            
            
            
            
            
            
        </div>
        <div>
            Powered by <a target="_blank" rel="noopener noreferrer" href="https://gohugo.io/">Hugo</a>, theme <a target="_blank" rel="noopener noreferrer" href="https://github.com/Junyi-99/hugo-theme-anubis2">Anubis2</a>.<br>
            

        </div>
    </div>

    <p class="h-card vcard">

    <a href=http://localhost:1313/ class="p-name u-url url fn" rel="me"></a>

    

    
</p>

</footer>

        
    </div>
</body>
</html>
